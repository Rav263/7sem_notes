\documentclass[a4paper, 12pt, titlepage, finall]{extreport}

%различные пакеты

\usepackage[T1, T2A]{fontenc}
\usepackage[russian]{babel}
\usepackage{tikz}
\usepackage{geometry}
\usepackage{indentfirst}
\usepackage{fontspec}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{array}
\graphicspath{{./images/}}

\usetikzlibrary{positioning, arrows}

\geometry{a4paper, left = 15mm, top = 10mm, bottom = 20mm, right = 15mm}

\setmainfont{Spectral Light}%{Times New Roman}
\setmonofont{DejaVu Sans Mono}
%\setcounter{secnumdepth}{3}
%\setcounter{tocdepth}{3}

\lstdefinestyle{customc}{
  belowcaptionskip=1\baselineskip,
  breaklines=true,
  frame=L,
  xleftmargin=\parindent,
  language=C,
  showstringspaces=false,
  basicstyle=\footnotesize\ttfamily,
  keywordstyle=\bfseries\color{green!40!black},
  commentstyle=\itshape\color{purple!40!black},
  identifierstyle=\color{blue},
  stringstyle=\color{orange},
}

\lstdefinestyle{customasm}{
  belowcaptionskip=1\baselineskip,
  frame=L,
  xleftmargin=\parindent,
  language=[x86masm]Assembler,
  basicstyle=\footnotesize\ttfamily,
  commentstyle=\itshape\color{purple!40!black},
}

\lstset{escapechar=@,style=customc}

\begin{document}

    \begin{titlepage}
        \begin{center}
            {\small \sc Московский государственный университет имени М.~В.~Ломоносова\\
            Факультет вычислительной математики и кибернетики\\
            Кафедра автоматизации систем вычислительных комплексов\\}
            \vfill
            {\large \sc Конспекты лекций.}\\~\\

            {\large \bf Языки программирования.}\\~\\

        \end{center}
        
        \begin{flushright}
            \vfill
            \vfill
            {Никифоров Никита Игоревич, 421 группа}\\
            {Лектор:}\\
            {Головин Игорь Генадьевич}\\
        \end{flushright}

        \begin{center}
            \vfill
            {\small Москва\\2020}
        \end{center}
    \end{titlepage}

    \chapter*{Аннотация}
        В данном курсе. 
        Скорее всего отчётностью будет экзамен. Если заочно то устный (Это что-то пи*** какой-то). Если очный то письменный. Почта лектора igolovin@gmail.com.
    \newpage
    \tableofcontents
    \newpage
    \chapter*{Введение}
        \addcontentsline{toc}{chapter}{\protect\numberline{}Введение}%
        Давайте обсудим, что такое Языки программирования (ЯП). Попробуем ввести определение ЯП.
        \begin{enumerate}
            \item Экстенсиальное $-$ Попробуем перечислить все языки программирования. Java, C, C++, C\#.
            В настоящее время насчитывается тысячи языков программирования. Поэтому данное определение нам не подходит.
            \item От обратного $-$ Обозначим что не является языком программирования: Русский, Английский, Эсперанто $-$ определённо нет!
            Нужна ли я алгоритмическая полнота для языка? Не обязательно: SQL-92 не является алгоритмически полным.
            \item Интенсиональное (Через свойства) $-$ ЯП, это инструмент для планирования поведения исполнителя. (В. Ш. Кауфман)
            ЯП $-$ формальноя нотация для записи компьютерных программ (CSS $-$ ЯП, но пробелы лишние не ставь!) 
        \end{enumerate}

        \underline{\bf Опр. 1} Исполнителем назовём управляеиое автоматическое поведение.\\
        Ford $-$ не исполнитель, так как водителю нужно крутить баранку, а вот Yandex мобиль $-$ вполне.
        Первый исполнитель $-$ ткацкие станки Жаккарда (начало 19-ого века).
        В нашем случае исполнителем будет универсальная вычислительная система. Мы будем рассматривать ЯП, которые удовлетворяют двум свойствам:
        \begin{itemize}
            \item Универсальность
            \item Индустриальность
        \end{itemize}
        \section*{Схема рассмотрения языков программирования}
            \addcontentsline{toc}{section}{\protect\numberline{}Схема рассмотрения языков программирования}%
            \begin{itemize}
                \item Базис
                    \subitem Скалярный (примитивные ТД и операции)
                    \subitem Структурный (составные ТД и классы)
            \end{itemize}
    \chapter{Виды Программирования}
        Определим виды программирования:
        \section{Игровое программирование}
            \underline{\bf Опр. 2} Игровое программирование $-$ необходимо для развлечения и обучения.\\
            Как пример задачи на ejudge (для себя, а не для Чернова).
            Первый игровой язык $-$ BASIC. Beginners All-purpose Symbolic Instruction Code.
            Второй самый популярный игровой язык $-$ Паскаль (1970).
\begin{lstlisting}
LET H$ = 'Hello'
LET W$ = 'world!'
PRINT H
PRINT W

DIM A(10)
FOR I = 1,10
A(I) = I
NEXT I
\end{lstlisting}
            Программы написаные на таких языках нужны только человеку их написавшему. А повторное использование стремится к нулю.
        \section{Научное программирование}
            \underline{\bf Опр. 3} Научное программирование $-$ программы написанные для выполнения какой-либо цели (вычисления, экспериментальное исследование и т.д.).\\
            Основное отличие от игровых ЯП $-$ программа написана и нужна определённому кругу людей. Повторное использование $-$ почти минимальное.
            Программа нужна для получения какого-то результата. Некоторые программы перерастают во что-то большее, но при этом обычно переписываются с нуля.
            Самый популярный и известный ЯП для научного программирования: \textbf{FOR}mulae \textbf{TRAN}slator $-$ (Джон Бэкус)
            FORTRAN $-$ самый первый и самый удачный.
            \begin{itemize}
                \item Чётко поставленный и достигнутые главные цели $-$ заменить посредника между математиком и компьютером, обеспечить приемлемую эффективность вычислений.
                \item Дополнительные эффекты (Неожиданные) $-$ прежде всего, мобильность знаний, которая была дополнена мобильностью программ, 
                что привело к накоплению ОГРОМНОГО количества библиотек для научных вычислений.
                \item До сих пор самый эффективный язык для "number crunching"
            \end{itemize}
            Чем плох FORTRAN:
            \begin{itemize}
                \item Только статические данные. Соответсвенно отсутствие рекурсии и динамических структур данных.
                \item Очень слабые и ненадёжные межмодульные связи.
                \item Отсутствие структурных управляющих конструкций (4 вида операций переходв, один оператор цикла и т.д.
                \item Единственная структура данных - массив (Как вектор, тензор)
                \item Единственный вид модуля - подпрограмма (функции и процедуры)
            \end{itemize}

\begin{lstlisting}
if (E) 10, 20, 30
\end{lstlisting}
             Если E < 0 переход на метку 10\\
             Если E == 0 переход на метку 20\\
             Если E > 0 переход на метку 30\\
             Наследние IBM 7090.\\
             FORTRAN $-$ Одновременно и самый плохой и самый удачный ЯП. Почему оба утверждения верны и не противорячат друг другу?
             Тут работает принцип экологической ниши языка.\\
             \underline{\bf Опр. 4} Экологическая ниша языка $-$ это проблемная область (или набор проблемных областей), в которой применяется ЯП.\\
             В ней может быть только одна доминанта, и вид должен подходить для этой ниши: если ЯП подходит для этой ниши, и он первый, то его от туда никто не вытеснит.
             Примеры проблемных областей:
             \begin{itemize}
                \item Научные высокопроизводительные вычисления.
                \item Научные эксперементальные вычисления.
                \item Системное программирование. (Си)
                \item Бухгалтерия, финансы (На самом деле - множество ПО) (Первый COBOL).
            \end{itemize}

            \underline{\bf Опр. 5} Занятие ниши $-$ означает то, что язык подходит для этой ниши, то есть пользователи языка (программисты) активно используют ЯП.\\
            Вытеснение языка из ниши происходит при изменнение условий в нише, а вовсе не из-за появления нового {\bf Ну очень офигенного}. 
            Именно поэтому Фортран до сих пор чувствуеет себя прекрасно в своей нише высокопроизводительных вычислений.
            А в экспериментальных вычислений он потихоньку уступает конкурентам (Python, Ruby, МатЛаб).
            Проблеммы FORTRAN начались, когда его стали использовать где попало. Например: системное программирование, управление устройствами и т.п.
            По причине его не надёжности.
            Надёжность языка характиризуется тем, насколько язык провоцирует надёжность (уменьшает надёжность)
            Пример:
\begin{lstlisting}
DO 5 I=1,3
A(I)=A(I) + C
5 CONTINUE
\end{lstlisting}
            
            {\bf НЕ ПУТАЙ ТОЧКИ И ЗАПЯТЫЕ, РАКЕТЫ ПАДАЮТ!!!}
            
            Вторым удачным языком для научных вычислений был АЛГОЛ (ALGOrithmic Language) $-$ первая версия (1958) год.
            Окончательный вариант АЛГОЛ-60
            Журнал Communication of ACM с 1960 годов, публикует алгоритмы на алголе-60.
        \section{Индустриальное программирование}
            Главные критерии различия $-$ круг пользователей программы и степень отчуждаемости.\\
            \underline{\bf Опр. 6} Индустриальное программирование $-$ создание программных продуктов, то есть программ и систем, 
            которые обязательно отчуждаются, то есть используются независимо от автора.\\
            Огромное количество проблемных областей.
            Требованиями к индустриальному ЯП будем называть технологическими требованиеми.
            Одним из самых важных технологических требований является возможность разделение программы на части, и их раздельная разработка (модульность).
            Примеры ТП:
            \begin{itemize}
                \item ПО - встроенное программное обеспечение работающее в реальном времени для низкоресурсных устройств (С++, Ада).
                \item Сайт магазина или стартапа, веб программирование (PHP, JavaScript, Python).
            \end{itemize}
            В данном курсе мы будем рассматривать ТОЛЬКО ЯП для индустриального программирования.
            Что мы будем изучать?
            \begin{enumerate}
                \item Как ЯП отвечают наиболее общим ТП.
                \item Общие свойства ЯП, используемых в современной индустрии разработки ПО (Различные парадигмы программирования).
            \end{enumerate}
            
    \chapter{ЯП и парадигмы программирования}
        \underline{\bf Опр. 7} Парадигма программирования - совокупность идей, методов. понятий, определяющих стиль программирования и способ мышления при создании программ.\\
        Существую три базисные парадигмы:
        \begin{itemize}
            \item императивная
            \item Функциональная
            \item Логическая
        \end{itemize}
        Все остальные подпарадигмы основаны на трёх базисных парадигмах и вкладываются в них. Например объектно-ориентированная парадигма основана на императивной парадигме.\\
        \underline{\bf Опр. 8} Обобщённое программирование (generic programming) $-$ статическая типизация типов (Родовые сегменты в Аде, шаблоны в c++).\\
        Зачем нам парадигма программирования? ВАжно понимать концепции парадигм и то, как они отражаются в конкретных ЯП.
        Современные индустриальные ЯП $-$ либо чисто императивные, либо содержат элементы других парадигм, но с доминированием одной.\\
        {\bf И тут Бэкус достаёт из кармана функциональные языки}\\
        Бэкус: Может ли программирование быть освобождено от фоннеймовской парадигмы?
        Чистые функциональные языки сложно назвать индустриальными. {\bf С функциональными языками как: Ты в дверь, они в окно}.
        При чём, многие вещи из функциональных языков перетикают идеи функциональных языков.
        Будем рассматривать алгоритм разварота входной последовательности символов.
    \chapter{Императивная парадигма}
        Основана на т.н. фон-неймановской модели
        \begin{itemize}
            \item ОЗУ <=> ЦПУ <=> ВЗУ.
            \item ОЗУ <=> программа + данные.
            \item ЦПУ <=> УУ + АЛУ
        \end{itemize}
        \underline{\bf Опр. 9} Главное понятие ИмпПП $-$ {\bf состояние} (храниться в памяти и ЦП).\\
        Существует некоторая функция, отображающее текущее состояние в следующее, такая функция и задаёт семантику работы программы.
        Команды ЯА:
        \begin{itemize}
            \item пересылки между ОП и регистрами ЦПУ (MOV)
            \item арифметико-логические команды (ADD)
            \item Команды управления (JMP, HALT)
            \item Команды ввода\\вывода.
        \end{itemize}
        Все команды в ЯА изменяют состояние. Состояние $-$ основное понятие императивных ЯП.
        Параллельность противоречит императивной парадигме.

        Оператор $-$ statement (loop statement, assignment statement,...)\\
        Операция $-$ operator (C++)\\
        
        В чём отличие операторов и операций? {\bf В понятии побочного эффекта, то есть изменения состояния при вычислении}:
        \begin{itemize}
            \item Для операции $-$ норма $-$ отсутствие побочного эффекта. (Плохо, когда функция меняет состояние)
            \item Для операторов $-$ побочный эффект $-$ смысл их существования.
        \end{itemize}
        {\bf Тут язык Си: Hold my beer}.
        В языке Си нет оператора присваивания, так как существует оператор-выражение expresion;
        Это принципиально меняет подход к языку. Си унаследовал от Алгола-68 такую особенность.\\
        \underline{\bf Опр. 10} Ортогональность $-$ взаимозаменяемость.\\
        \underline{\bf Опр. 11} Независимость языковых конструкций $-$ допустимые конструкции имеют смысл в любом осмосмысленном контексте и могут быть взаимозаменямыми.\\
        Оператор не ортоганален выражению.
        Чтобы сделать оператор ортогональным, ему нужно дать значение. Выражденое значение $-$ тоже значение.
        Операторы имеют вычисляемое значение, а выражения - побочный эффект, поэтому они взаимозаменяемы.
        В Алголе-68 был описан не только синтаксис, но и семантику (С помощью двух уровневых грамматик какого-то мужика).

        \section{Задача о реверсе входной последовательности}
            Классическая задача обработки данных $-$ последовательность шагов.

            \begin{enumerate}
                \item Получить последовательность со входа.
                \item Сохранить в какой-нибудь контейнер.
                \item Перевернуть исходную последовательность.
                \item Вывести перевёрнутую последовательность.
            \end{enumerate}

        Рассмотрим простейшие примеры программ на различных языках.
        \subsection{Реверс последовательности на Си}
            Первый вариант программы надёжен, но присутствуют ограничения, которые не обговаривались в первоночальном условии.
            \lstinputlisting[language=C]{./examples/lection_1/reverse1.c}
            Более правильный вариант программы с использованием динамической памяти представлен во втором примере.
            \lstinputlisting[language=C]{./examples/lection_1/reverse2.c}
            Из особенностей можно выделить статическую явную типизацию, а также прямую работу с динамической памятью.
            Опять же второй код написан безопасно, и отслеживает переполнение динамической памяти.
        \subsection{Реверс последовательности на Go}
            В первом примере программа написана не корректно, предлагается посмотреть внимательно, и понять в чём ошибка.
            \lstinputlisting[language=Go]{./examples/lection_1/bad_go.go}
            
            На самом деле всё просто. В Go отсутствует тип данных char, из-за чего такой вывод последовательности не верен, и вместо
            побуквенного вывода строки мы получаем побайтовый вывод, что в корне не соответствует нашей задаче.
            Рассмотрим второй пример на котором данная ошибка исправлена.
            \lstinputlisting[language=Go]{./examples/lection_1/good_go.go}
            
            Вместо типа char, в Go используется тип динамической строки. Которая разбивается на маленькие подстроки, а потом соединяется в целую строку в обратной последовательности.
            И только потом печатается на экран.
            Первый язык Си появился в 1969 году был образован от цепочки языков. CPL=>BCPL=>B=>C. От B язык Си унаследовал
            скобки, синтаксис управляющих конструкций, устаревший синтаксис функций и auto.
            Существующие стандарты C89, C99, C11, C18, C2x
        \section{Язык Go}
            Язык Go (Google $-$ К. Томпсон, Р. Пайк, Р. Гризмер)
            Из особенностей можно выделить отказ от некоторых концепций ООЯП 
            (отсутствие понятия класса с наследованием, перегрузка функций, обобщённое программирование).
            Отказ от большинства оопераций с побочным эффектом и адресной арифметики.
            Автоматическая сборка мусора, очень развитая многопточность, есть элементы ФП (замыкания, анонимные функции).
            Его ниша $-$ разработка прикладных сервисов и утилит, но не системное программирование.
            В OS Fuchsia пытались использовать Go, но в итоге не вышло.
        \section{Императивная парадигма язык Python}
            Ведущий в нише научного программирования, где нет огромного количества вычислений с плав. точкой.
            Python $-$ интерпритируемый язык с динамической типизацией и автоматической сборкой мусора, наследник языка ABC.
            Первая версия появилась в 1991 (Гвидо Ван Россум BDFL (Благожилательный диктатор пожизенно) 2018).
            Python 2 $-$ появился в 2000 и закончил свою поддержку на версии 2.7.18 в 2020.
            Python 3 $-$ (Не полностью совместим с 2) $-$ 2008 год, текущая версия 3.9.1.
            Разработкой языка занимается сообщество питонистом $-$ роль стандартов играют PEP (Python Enchancement Proposals)
            При развитии языка появились элементы ФП и ООП, очень огромная стандартная библиотека и пользовательская дбиблиотека.
            Его ниша плавно перетекает с научного в индустриальное программирование. и веб программирование.
            Он уступает по производительности многим языкам.\\
            \textbf{Есть два стула c++ и Python, а Go посередине}\\
            В Python нет реверса строк \textbf{И это правильно}, зато есть мощное понятие вырезки.
    \chapter{Объектно-императивная пардигма}
        Объект <=> состояние + поведение (класс)
        Главный механизм данной парадигмы $-$ передача сообщений.
        Состояние => структура данных. Поведение => процедуры и функции, аргументом которых является объект.
        Объекты посылают друг другу сообщения $-$ посылка сообщения это вызов соответствующего метода класса. 
        В с++ это виртуальные методы, Smalltalk $-$ динамический поиск метода-обработчика сообщения.
        Классом назвается набор параметров и методов $-$ функций для доступа к параметрам. При этом метод это именно функция доступа.
        Объекты с идентичной структурой состояния и идентичным поведением объединяются в понятие типа данных.
        Важным моментом является понятие отношений между классами.
        Также Объекто-импертаивная парадигма отличается богатой стандартной библиотекой.

        \section{Язык C\#}
\begin{lstlisting}
using System;
public class Program {
    static void Main(string[] args) {
        string s = Console.In.ReadToEnd();
        char[] seq = s.ToCharArray();
        Array.Reverse(seq);
        Console.Write(seq);
    }
}
\end{lstlisting}
            Одна из причин почему нет ревеса $-$ необходимо переставить элементы.
            Внутри строки нельзя переставить элементы, так как в большинстве своём строки неизменяемы.
            А вот массивы $-$ изменяемый тип данных и поэтому там есть разворот \textbf{Array.Reverse}.
        \section{Обобщённое программирование язык С++}
            Обобщённое программирование $-$ программирование где все типы статические.
            Применяется механизм шиблонов. В С++ стандартная библиотека состоит из CRTL и STL.
            CRTL $-$ C Runtime Library, стандартная библиотека C.
            STL $-$ Библиотека в которой находятся контеёнеры и алгоритмы, причм контейнеры ничего не знают о алгоритмах,
            а алгоритмы ничего не знают о контейнерах. А как же совместить? Используются итераторы, некоторое подобие указателей.
            Для реализации задачи сначала выберается алгоритм, а затем контейнер, с которым выбранный алгоритм будет эффективно работать.
            При этом \textbf{cin} $-$ так же контейнер. Как пример для реверса последовательности нам нужен контейнер с двуноправленным 
            итератором. Алгоритм $-$ копирование \textbf{copy(beginIt, endIt, whereIt)}.
            Немного пвсевдокода, как вставлять в массив с помощью итератора?
\begin{lstlisting}
std::vector v;
copy_from_cin_to_v: copy(begin_it_cin, end_it_cin, iterToV)
\end{lstlisting}
            Для получения итераторов cin используется \textbf{istream\_iterator}.
            При этом:
            \begin{itemize}
                \item istream\_iterator(cin) $-$ аналог begin()
                \item istream\_iterator() $-$ аналог end()
            \end{itemize}
            Также есть \textbf{back\_inserter} $-$ аналог \textbf{push\_back()}.

\begin{lstlisting}
#include<iostream>
#include<vector>
#include<algorithm>
#include<iterator>

using namespace std;

int main() {
    std::vector<char> v;
    std::copy(istream_iterator<char>(cin), istream_iterator<char>(), back_inserter(v));
    std::copy(v.rbegin(), v.rend(), ostream_iterator<char>(cout));
}
\end{lstlisting}
            Таким образом, в С++ можно достичь огромный уровень абстрации.
    \chapter{Функциональная парадигма}
        Основная концепция:
        \begin{itemize}
            \item основные операции $-$ вызов (вычисление) функции и композиция функций.
            \item функции $-$ базисные + определяемые программистом
            \item функции $-$ объекты первого порядка, то есть могут быть значениями переменных, воззвращаемыми
                и передаваемыми значениями, могут быть созданы динамически (не путать с вызовом функции)
            \item переменные не меняют значения, а отождествляются со своими значениями на всё время существования переменной.
        \end{itemize}
        Таким образом, понятие явного хранимомго состояния отсутствует. 
        При чём программы на функциональных языках значительно проще распараллеливать чем на императивных.
        Функциональные языки: FP, Haskell, Lisp, ML, Hope, Miranda.
        \section{Язык COMON Lisp}
            Почему Lisp?
            \begin{itemize}
                \item Первый ЯП с элементами функциональными конструкциями
                \item ...
                \item ...
            \end{itemize}

            \textbf{Lis}t \textbf{P}rocessing $-$ 1958 Джон Маккарти (MIT) $-$ вначале чисто теоритический инструмент.
            Далее (1959-62) превратился в ЯП для обработки символьной информации. Стал de-facto стандартом в нише исследований по ИИ.
            
            Примитивными данными в Lisp являются атомы.
            Атом $-$ символ или целая константа (произвольного размера)
            Особым атомом является \textbf{()}, другое обозначение \textbf{NIL}, является обозначением пустого списка.
            Пример:
\begin{lstlisting}
ident 42 + NIL T
\end{lstlisting}
            Главная и единственная структура данных $-$ S-выражение, которая является атомом с точечной парой.
            Точечной парой является пара S-выражений причём голова является либо атомом либо списком, а хвост может быть только списком.
            Пример: 
\begin{lstlisting}            
(a . b) - неверно
(nil . abc) - неверно
(nil . nil) - верно
(a . (b . c)) - неврно
(a . (b . (c . nil))) - верно
\end{lstlisting}
            Парадигма работы интерпритатора Lisp $-$ REPL (Read Evaluate Print Loop).
            Атом вычисляет сам себя, пустой список тоже сам себя вычисляет. А атом символ вычисляет себя в значение.
            Символ инициализируется двумя способами: символ базисный, либо мы его задали какой-либо функцией.
            Как вычисляется список? Берётся первый элемент, который обязан быть определённым символом, он не вычисляется.
            Затем вычисляются все остальные символы, отождествляются с порядком аргументов функции и вычисляется тело функции.
\begin{lstlisting}
>>> 5
5
>>> nil
NIL
>>> A
ERROR
>>> (+ 1 2 3)
6
\end{lstlisting}
            Ещё стандартные функции:
            \begin{itemize}
                \item (CAR S) $-$ возвращает голову точечно пары списка S.
                \item (CDR S) $-$ возвращает хвост точечной пары списка S, при этом если S $-$ атом, то будет ошибка.
                \item (CONS A B) $-$ возвращает правильную точечную пару А В
            \end{itemize}
            Так же есть специальные функции, например \textbf{QUOTE}, которая просто отменяет вычисления списка.
            \textbf{CDDR} $-$ CDR от CDR.
\begin{lstlisting}
>>> (CAR A)
ERROR
>>> (CAR (QOUTE (A B)))
A
>>> (CDR (QOUTE (A B)))
(B)
>>> (CDDR (QOUTE (A B)))
()
>>> (CONS (QUOTE A) ())
(A)
>>> (CONS (QUOTE A) (B C))
(A B C)
\end{lstlisting}
            \textbf{QUOTE} стали заменять символом \'.
            Другая специальная функция \textbf{(IF B S1 S2)}, вычисляет B, если B истино, то вычисляется S1, иначе S2.
            А что такое истина? Если 0 то ложно, иначе истино. Т.е. если B вычислится как пустой указатель $-$ nil, то ложь,
            иначе истина. \textbf{NULL A} $-$ если A - пустой список, то возвращает T, иначе NIL.
            Решим теперь задачу о реверсе входной последовательности
\begin{lstlisting}
>>> (print (reverse (quote (a b c))))
(c b a)
>>> (print (reverse (read)))
(a b c)
(c b a)
\end{lstlisting}
            Давайте посмотримна наивное решение нашей задачи о перевороте последовательности.
\begin{lstlisting}
(default reverse1(a)
    (if (null s)
        s
        (append (reverse1 (cdr s)) (cons (car s) ()))
    )
)
\end{lstlisting}
            В чём наивность такой реализации? Она имеет квадратичную сложность, 
            таким образом, функциональная парадигма не избавляет от необходимости думать оо эффективности.

            Решением данной проблемы, является использование метода накопительного параметра. А именно добавить функцию сдвига,
            которая из первого аргумента переносит голову в правый список.
\begin{lstlisting}
(defun shif(l r)
    (if (null l)
        r
        (shift (cdr l) (cons (car l) r))
    )
)
(defun reverse1 (s) (shift s nill))
\end{lstlisting}
    \chapter{Аппликативная парадигма (язык Рефал)}
        REFAL $-$ \textbf{Re}cursive \textbf{A}lgorithmic \textbf{L}anguage. (В.Ф. Турчин (СССР-США) 1966-1968)
        Рассматривает сразу поле ввода $-$ последовательность литеров (a=b).
        Если поле ввода соответствует образцу (a), то оно преобразует в b.
        Рассмотрим простую программу проверки палиндрома на языке РЕФАЛ.
\begin{lstlisting}
Palindrom {
            = "Yes" /;
s.1         = "Yes" /;
s.1 e.1 s.1 = <Palindrome e.1> /;
e.1         = "No" /;
}
\end{lstlisting}
\begin{lstlisting}
ENTRY Go
{
    = <Prout<Reverse1<Card>>>/;
}
Reverse1
{
    s.1 e.1 = <Reverse e.11> s.1/;
            = /;
}
\end{lstlisting}
    \chapter{Логическая парадигма (язык Пролог)}
        Prolog $-$ \textbf{Pro}gramming in \textbf{Log}ic $-$ 1971 $-$ А. Колмерое.
        Идея $-$ описать семантику задачи в терминах формул исчисления предикатов (в некоторой нормализованной форме).
        Спецификация задачи = программа, решающая задачу.
        Скалярый базис $-$ простые данные
        \begin{itemize}
            \item константы
                \subitem атомы (=символы, но со строчной буквой в начале)
                \subitem числа (1 2 3)
            \item переменные (=идентификаторы, но с прописной буквы.)
        \end{itemize}
        Структурный базис $-$ списки [1, 2, 3], []. Программа на прологе $-$ это описание предикатов.
        Предикаты в (ФП $-$ логические функции). Как же описать произвольную функцию в виде предиката?
        Добавить просто дополнительный аргумент $-$ результат.
\begin{lstlisting}
append([], [1, 2], [1, 2]) = True.
append([], [1, 2], [1, 2, 3]) = False.
append([1], [2, 3], [1, 2, 3]) = True.
append([X], [2, 3], [X, 2, 3]) = True.
\end{lstlisting}
        Предикаты описываются с помощью фактов и правил. Факт $-$ имя предиката и набор константных аргументов.
        Правила соеденяются в единую формулу путём логической операции 'или'. Фактически получаем единую фурмулу Хорновскую нормальную форму $-$
        дизъюнкция имликаций.
        Пример $-$ силлогизм Сократа (каждый человек смертен, Сократ человек, значит он $-$ смертен)
\begin{lstlisting}
man(sokrat).
mortal(X) :- man(X).
? - mortal(sokrat).
true.
\end{lstlisting}
        Посмотрим решение задачи о реверсе.
\begin{lstlisting}
reverse1([], []).
reverse1([X|Q, Z) :- reverse1(Q, Y), append(Y, [X], Z).

reverse2 :-shift(X, [] Y).
reverse2(X) = shift(X, ())

shift([], X, X).
shift((), X) = X
shift([H|T], R, Z) :- shift(T, [H|R], Z)
\end{lstlisting}
    \chapter{Основные понятия ЯП}
        Являются ли понятия оператора, константы, адреса универсальными понятиями любого ЯП?
        Для модели вычислительных систем Фон-Неймана $-$ естественно. Но являются ли эти понятия именно понятиями ЯП?
        Они являются понятиями императивной модели программирования. Так что данные понятия не являются универсальными.
        А вот понятие переменной, формально не является, но фактически присутствует почти во всех ЯП не зависимо от парадигмы.
        В Императивной парадигме $-$ абстрактное понятие места в памяти.
        В функциональной парадигме $-$ ближе к математическому понятию. 
        Основные понятия любого ЯП:
        \begin{itemize}
            \item Данные
            \item Операции
            \item Связывание
        \end{itemize}

        Программа это данные, оперции и есть работа с данными. Для каждого ЯП сой набор операций и данных, существует
        понятие дуализма операций и данных.
        Примеры:
        \begin{itemize}
            \item операция, которая возвращает длину строки, это операция вычисления или считывания данных? Зависит от ЯП.
            \item мемоизация значений вместо вычисления.
            \item понятие свойства в ЯП.
        \end{itemize}

        Свойство как понятие ЯП:
\begin{lstlisting}
class WithProperty {
    int _x = 0;
    public int X {
        get {return _x;}
        set {_x = value;}
    }
}

class ClsWithProperty2 {
    public int Y {get; set;}
    publec ClsWithProperty2() {Y = 0;}
}

static void main(string[] args)
{
    WithProperty a = new WithProperty();
    ClsWithProperty2 b = new ClsWithProperty2();
    a.X = 1; // setter выглядит как данные, а на самом деле - операции.
    b.Y = -1; // setter
    Console.Write(a.X + b.Y); // getter
}
\end{lstlisting}
        Таким образом в С\# достаточно нативно сделан доступ к данным, а именно с помощью операций (свойств) \textbf{setter}, \textbf{getter}.
        Причём такие свойства и операции присваивания могут быть достаточно сложными операциями, например, обращение к библиотечным функциям.

        \section {Данные и операции}
            Данные групируются в \textbf{типы данных}. Тип данных характеризуется множеством значений. (Например перецисляемый тип,
            как простое перечисление множество значений). Тип данных $-$ множество значений и множество операций, мы не можем рассматривать тип данных в отрыве от множества значений. 
            Главным в типе данных является сигнатура, сигнатура $-$ множество сигнатур, операций над этипом данных.
            Во многом развите ушло в абстрактные типы данных, которые представляют из себя типы данных без множества значений,
            то есть тип данных стостоит только из сигнатур. Изначально была идея описывать семантику сигнатур рассматриваемого типа данных.
            То есть, задавались математические свойства сигнатур. Что позволяло делать формальные доказательства корректности работы программы.
            В данный момент времени от такого ушли, так как формальные доказательства ушли из практики программирования.
            \textbf{То что выглядит как данные, на самом деле операции}.
        \section{связывание}
            Поговорим про связывание. \textbf{Связывание} $-$ процесс установки связи между элементом программы и конкретным атрибутом или характеристикой.
            Сводится к выбору атрибута из возможно конечного набора атрибутов. Реализация связывания для каждого ЯП уникальна.
            \textbf{Время связывания} $-$ это момент установления этой связи. Основные виды времён связывания:
            \begin{itemize}
                \item Во время выполнения программы $-$ динамическое связывание.
                \item Во время трансляции или компановки $-$ статическое связывание.
            \end{itemize}
            Чем константа отличается от переменной?
            В императивной парадигме основное связывание $-$ связывание объекта данных со значением.
            Следовательно, если используется статическое связывание, то константа, а если динамическое, то переменное.
            Так когда связывается значение с константой? Если во время компиляции, то это чисто статическое связывание 
            (Паскаль, C++)
\begin{lstlisting}
const int N = 1024;
int arr[N];
\end{lstlisting}
            В C\# пример с массивами не подойдёт, так как там все массивы по умолчанию динамические.
            А что там в C?
\begin{lstlisting}
K&R C: константы на уроне препроцессора
#define N 1024
#define A 10.0
#define H ((A)/((N) + 1))
C90: константы на уровне компилятора
const int N = 1024;
const double A = 10.0;
const double H = A/(N+1);
\end{lstlisting}
            \textbf{Скобки обязательны!!} при использовании \textbf{define}, потому что \textbf{define} протое подставление текста. 
            Именно поэтому в C89, добавили \textbf{const ...} $-$ такие константы.
            Возникает два понятия константы:
            \begin{itemize}
                \item статическая инициализация.
                \item динамическая инициализация.
            \end{itemize}
\begin{lstlisting}
class ConstSample {
    public const int N = 1024; Чисто статическая инициализация. При этом память выделяется отдельно от класса.
    public readonly double H; Динамическая инициализация.

    public ConstSample(double Dist) {
        H = Dist / (N + 1); То есть инициализация чисто физически не может быть статической.
    }
}
\end{lstlisting}
            А шо там у c++?
\begin{lstlisting}
\end{lstlisting}
            Другой пример важности понятия времени связывания $-$ виртуальные и не виртуальные методы в C++.
            Отличие только во времени связывания \textbf{Вызвова} функции.
            Реализация (сгенерированный код) виртуальной и не виртуальной функции не отличаются. 
\begin{lstlisting}
\end{lstlisting}
            В языках ассемблера есть специальны команды косвенного вызова по адресу.
            Так же в С++ есть способ снятия виртуальности.
            Языки бывают: компилируемые, интерпретироуемые, типизируемые, слабо типизируемые.
            На самом деле главное отличие в связываниях, так как любой язык может компилироваться, любой язык может интерпретироваться.
            В любом языке есть данные, а значит есть типы данных. Интерпритатор языка $-$ С любой процессора, поэтому написание интерпритатора
            языка C не целесообразно.

            Если связывание типа данных с объектом данных статическое, то типизация статическая.
            А если связывание динамическое, то типизация динамическое.
            Слаботипизированный $-$ тип чего либо (ссылки) может менятся.
            Сильнотипизированный $-$ тип чего либо (ссылки) не меняется.
\begin{lstlisting}
JavaScript: Слаботипизированный.
a + b // Если a - строка, b - число, то на выходе мы получим строку a + to_string(b)
Python: Сильнотипизированный
a + b // Если a - строка, b - число, то мы получим ошибку.
\end{lstlisting}
            Если компиляция не даёт существенный выйгрыш производительности, то язык интерпритируемый. Иначе компилируемый.
            Обычно если используется динамическая типизация, то обычно язык интерпритируемый. Если мы скомпилируем Lisp, то 
            он просто засунет в программу интерпритатор лиспа, поэтому выйгрыша нет.
            \subsection{Статическое связывание}
                \begin{itemize}
                    \item По выбору программиста. Это, например, связывание объекта данных с именем, имени с типом и т.д.
                    \item По выбору транслятора. Это, например, связывание относительно адреса локальных переменных.
                        Конкретный вариант такого связывания, как правило определяется реализацией языка.
                    \item По выбору компоновщика (загрузчика, редактора связей). при ссылке на переменную 
                        или вызове подпрограммы из другого модуля связать конкретные адреся с местом ссылки. 
                        Такое связывание возможно только на этапе компоновки, когда доступны все используемые модули и библиотеки
                        и известин их относительный порядок.
                \end{itemize}
            \subsection{Динамическое связывание}
                \begin{itemize}
                    \item При входе в блок (тело подпрограммы). Например, в этот момент локальные переменные блока 
                        и формальные параметры подпрограммы связываются с атрибутом $-$ адресом. Связывание фактических и формальных
                        параметров тоже происходитв этот момент. И оно остаётся неизменным до входа из блока. 
                        Такое способ мы будем называть \textbf{квазистатическими}.
                    \item В произвольной точке программного кода. К этому виду относится, например, связывание переменной и значения.
                        Также связывание адрема и объекта при динамическом распределении памяти, выбор обработчика исклюсительной 
                        ситуации при распространении исключения. Основное отличеи от статического или квазистатического связывание,
                        никогда заранее не известен момент уничтожения связывания. Например, динмический сборщик мусора.
                \end{itemize}
            \subsection{Другие виды времени связыванияi}
                \begin{itemize}
                    \item Во врем реализации языка (Например выбор максимального и минимального значения int)
                    \item Во время определения языка (Например нумеклатура всех типов языка)
                \end{itemize}
\end{document}
