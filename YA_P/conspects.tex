\documentclass[a4paper, 12pt, titlepage, finall]{extreport}

%различные пакеты

\usepackage[T1, T2A]{fontenc}
\usepackage[russian]{babel}
\usepackage{tikz}
\usepackage{geometry}
\usepackage{indentfirst}
\usepackage{fontspec}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{array}
\graphicspath{{./images/}}

\usetikzlibrary{positioning, arrows}

\geometry{a4paper, left = 15mm, top = 10mm, bottom = 20mm, right = 15mm}

\setmainfont{Spectral Light}%{Times New Roman}
\setmonofont{DejaVu Sans Mono}
%\setcounter{secnumdepth}{3}
%\setcounter{tocdepth}{3}

\lstdefinestyle{customc}{
  belowcaptionskip=1\baselineskip,
  breaklines=true,
  frame=L,
  xleftmargin=\parindent,
  language=C,
  showstringspaces=false,
  basicstyle=\footnotesize\ttfamily,
  keywordstyle=\bfseries\color{green!40!black},
  commentstyle=\itshape\color{purple!40!black},
  identifierstyle=\color{blue},
  stringstyle=\color{orange},
}

\lstdefinestyle{customasm}{
  belowcaptionskip=1\baselineskip,
  frame=L,
  xleftmargin=\parindent,
  language=[x86masm]Assembler,
  basicstyle=\footnotesize\ttfamily,
  commentstyle=\itshape\color{purple!40!black},
}

\lstset{escapechar=@,style=customc}

\begin{document}

    \begin{titlepage}
        \begin{center}
            {\small \sc Московский государственный университет имени М.~В.~Ломоносова\\
            Факультет вычислительной математики и кибернетики\\
            Кафедра автоматизации систем вычислительных комплексов\\}
            \vfill
            {\large \sc Конспекты лекций.}\\~\\

            {\large \bf Языки программирования.}\\~\\

        \end{center}
        
        \begin{flushright}
            \vfill
            \vfill
            {Никифоров Никита Игоревич, 421 группа}\\
            {Лектор:}\\
            {Головин Игорь Генадьевич}\\
        \end{flushright}

        \begin{center}
            \vfill
            {\small Москва\\2020}
        \end{center}
    \end{titlepage}

    \chapter*{Аннотация}
        В данном курсе. 
        Скорее всего отчётностью будет экзамен. Если заочно то устный (Это что-то пи*** какой-то). Если очный то письменный. Почта лектора igolovin@gmail.com.
    \newpage
    \tableofcontents
    \newpage
    \chapter*{Введение}
        \addcontentsline{toc}{chapter}{\protect\numberline{}Введение}%
        Давайте обсудим, что такое Языки программирования (ЯП). Попробуем ввести определение ЯП.
        \begin{enumerate}
            \item Экстенсиальное $-$ Попробуем перечислить все языки программирования. Java, C, C++, C\#.
            В настоящее время насчитывается тысячи языков программирования. Поэтому данное определение нам не подходит.
            \item От обратного $-$ Обозначим что не является языком программирования: Русский, Английский, Эсперанто $-$ определённо нет!
            Нужна ли я алгоритмическая полнота для языка? Не обязательно: SQL-92 не является алгоритмически полным.
            \item Интенсиональное (Через свойства) $-$ ЯП, это инструмент для планирования поведения исполнителя. (В. Ш. Кауфман)
            ЯП $-$ формальноя нотация для записи компьютерных программ (CSS $-$ ЯП, но пробелы лишние не ставь!) 
        \end{enumerate}

        \underline{\bf Опр. 1} Исполнителем назовём управляеиое автоматическое поведение.\\
        Ford $-$ не исполнитель, так как водителю нужно крутить баранку, а вот Yandex мобиль $-$ вполне.
        Первый исполнитель $-$ ткацкие станки Жаккарда (начало 19-ого века).
        В нашем случае исполнителем будет универсальная вычислительная система. Мы будем рассматривать ЯП, которые удовлетворяют двум свойствам:
        \begin{itemize}
            \item Универсальность
            \item Индустриальность
        \end{itemize}
        \section*{Схема рассмотрения языков программирования}
            \addcontentsline{toc}{section}{\protect\numberline{}Схема рассмотрения языков программирования}%
            \begin{itemize}
                \item Базис
                    \subitem Скалярный (примитивные ТД и операции)
                    \subitem Структурный (составные ТД и классы)
            \end{itemize}
    \chapter{Виды Программирования}
        Определим виды программирования:
        \section{Игровое программирование}
            \underline{\bf Опр. 2} Игровое программирование $-$ необходимо для развлечения и обучения.\\
            Как пример задачи на ejudge (для себя, а не для Чернова).
            Первый игровой язык $-$ BASIC. Beginners All-purpose Symbolic Instruction Code.
            Второй самый популярный игровой язык $-$ Паскаль (1970).
\begin{lstlisting}
LET H$ = 'Hello'
LET W$ = 'world!'
PRINT H
PRINT W

DIM A(10)
FOR I = 1,10
A(I) = I
NEXT I
\end{lstlisting}
            Программы написаные на таких языках нужны только человеку их написавшему. А повторное использование стремится к нулю.
        \section{Научное программирование}
            \underline{\bf Опр. 3} Научное программирование $-$ программы написанные для выполнения какой-либо цели (вычисления, экспериментальное исследование и т.д.).\\
            Основное отличие от игровых ЯП $-$ программа написана и нужна определённому кругу людей. Повторное использование $-$ почти минимальное.
            Программа нужна для получения какого-то результата. Некоторые программы перерастают во что-то большее, но при этом обычно переписываются с нуля.
            Самый популярный и известный ЯП для научного программирования: \textbf{FOR}mulae \textbf{TRAN}slator $-$ (Джон Бэкус)
            FORTRAN $-$ самый первый и самый удачный.
            \begin{itemize}
                \item Чётко поставленный и достигнутые главные цели $-$ заменить посредника между математиком и компьютером, обеспечить приемлемую эффективность вычислений.
                \item Дополнительные эффекты (Неожиданные) $-$ прежде всего, мобильность знаний, которая была дополнена мобильностью программ, 
                что привело к накоплению ОГРОМНОГО количества библиотек для научных вычислений.
                \item До сих пор самый эффективный язык для "number crunching"
            \end{itemize}
            Чем плох FORTRAN:
            \begin{itemize}
                \item Только статические данные. Соответсвенно отсутствие рекурсии и динамических структур данных.
                \item Очень слабые и ненадёжные межмодульные связи.
                \item Отсутствие структурных управляющих конструкций (4 вида операций переходв, один оператор цикла и т.д.
                \item Единственная структура данных - массив (Как вектор, тензор)
                \item Единственный вид модуля - подпрограмма (функции и процедуры)
            \end{itemize}

\begin{lstlisting}
if (E) 10, 20, 30
\end{lstlisting}
             Если E < 0 переход на метку 10\\
             Если E == 0 переход на метку 20\\
             Если E > 0 переход на метку 30\\
             Наследние IBM 7090.\\
             FORTRAN $-$ Одновременно и самый плохой и самый удачный ЯП. Почему оба утверждения верны и не противорячат друг другу?
             Тут работает принцип экологической ниши языка.\\
             \underline{\bf Опр. 4} Экологическая ниша языка $-$ это проблемная область (или набор проблемных областей), в которой применяется ЯП.\\
             В ней может быть только одна доминанта, и вид должен подходить для этой ниши: если ЯП подходит для этой ниши, и он первый, то его от туда никто не вытеснит.
             Примеры проблемных областей:
             \begin{itemize}
                \item Научные высокопроизводительные вычисления.
                \item Научные эксперементальные вычисления.
                \item Системное программирование. (Си)
                \item Бухгалтерия, финансы (На самом деле - множество ПО) (Первый COBOL).
            \end{itemize}

            \underline{\bf Опр. 5} Занятие ниши $-$ означает то, что язык подходит для этой ниши, то есть пользователи языка (программисты) активно используют ЯП.\\
            Вытеснение языка из ниши происходит при изменнение условий в нише, а вовсе не из-за появления нового {\bf Ну очень офигенного}. 
            Именно поэтому Фортран до сих пор чувствуеет себя прекрасно в своей нише высокопроизводительных вычислений.
            А в экспериментальных вычислений он потихоньку уступает конкурентам (Python, Ruby, МатЛаб).
            Проблеммы FORTRAN начались, когда его стали использовать где попало. Например: системное программирование, управление устройствами и т.п.
            По причине его не надёжности.
            Надёжность языка характиризуется тем, насколько язык провоцирует надёжность (уменьшает надёжность)
            Пример:
\begin{lstlisting}
DO 5 I=1,3
A(I)=A(I) + C
5 CONTINUE
\end{lstlisting}
            
            {\bf НЕ ПУТАЙ ТОЧКИ И ЗАПЯТЫЕ, РАКЕТЫ ПАДАЮТ!!!}
            
            Вторым удачным языком для научных вычислений был АЛГОЛ (ALGOrithmic Language) $-$ первая версия (1958) год.
            Окончательный вариант АЛГОЛ-60
            Журнал Communication of ACM с 1960 годов, публикует алгоритмы на алголе-60.
        \section{Индустриальное программирование}
            Главные критерии различия $-$ круг пользователей программы и степень отчуждаемости.\\
            \underline{\bf Опр. 6} Индустриальное программирование $-$ создание программных продуктов, то есть программ и систем, 
            которые обязательно отчуждаются, то есть используются независимо от автора.\\
            Огромное количество проблемных областей.
            Требованиями к индустриальному ЯП будем называть технологическими требованиеми.
            Одним из самых важных технологических требований является возможность разделение программы на части, и их раздельная разработка (модульность).
            Примеры ТП:
            \begin{itemize}
                \item ПО - встроенное программное обеспечение работающее в реальном времени для низкоресурсных устройств (С++, Ада).
                \item Сайт магазина или стартапа, веб программирование (PHP, JavaScript, Python).
            \end{itemize}
            В данном курсе мы будем рассматривать ТОЛЬКО ЯП для индустриального программирования.
            Что мы будем изучать?
            \begin{enumerate}
                \item Как ЯП отвечают наиболее общим ТП.
                \item Общие свойства ЯП, используемых в современной индустрии разработки ПО (Различные парадигмы программирования).
            \end{enumerate}
            
    \chapter{ЯП и парадигмы программирования}
        \underline{\bf Опр. 7} Парадигма программирования - совокупность идей, методов. понятий, определяющих стиль программирования и способ мышления при создании программ.\\
        Существую три базисные парадигмы:
        \begin{itemize}
            \item императивная
            \item Функциональная
            \item Логическая
        \end{itemize}
        Все остальные подпарадигмы основаны на трёх базисных парадигмах и вкладываются в них. Например объектно-ориентированная парадигма основана на императивной парадигме.\\
        \underline{\bf Опр. 8} Обобщённое программирование (generic programming) $-$ статическая типизация типов (Родовые сегменты в Аде, шаблоны в c++).\\
        Зачем нам парадигма программирования? ВАжно понимать концепции парадигм и то, как они отражаются в конкретных ЯП.
        Современные индустриальные ЯП $-$ либо чисто императивные, либо содержат элементы других парадигм, но с доминированием одной.\\
        {\bf И тут Бэкус достаёт из кармана функциональные языки}\\
        Бэкус: Может ли программирование быть освобождено от фоннеймовской парадигмы?
        Чистые функциональные языки сложно назвать индустриальными. {\bf С функциональными языками как: Ты в дверь, они в окно}.
        При чём, многие вещи из функциональных языков перетикают идеи функциональных языков.
        Будем рассматривать алгоритм разварота входной последовательности символов.
    \chapter{Императивная парадигма}
        Основана на т.н. фон-неймановской модели
        \begin{itemize}
            \item ОЗУ <=> ЦПУ <=> ВЗУ.
            \item ОЗУ <=> программа + данные.
            \item ЦПУ <=> УУ + АЛУ
        \end{itemize}
        \underline{\bf Опр. 9} Главное понятие ИмпПП $-$ {\bf состояние} (храниться в памяти и ЦП).\\
        Существует некоторая функция, отображающее текущее состояние в следующее, такая функция и задаёт семантику работы программы.
        Команды ЯА:
        \begin{itemize}
            \item пересылки между ОП и регистрами ЦПУ (MOV)
            \item арифметико-логические команды (ADD)
            \item Команды управления (JMP, HALT)
            \item Команды ввода\\вывода.
        \end{itemize}
        Все команды в ЯА изменяют состояние. Состояние $-$ основное понятие императивных ЯП.
        Параллельность противоречит императивной парадигме.

        Оператор $-$ statement (loop statement, assignment statement,...)\\
        Операция $-$ operator (C++)\\
        
        В чём отличие операторов и операций? {\bf В понятии побочного эффекта, то есть изменения состояния при вычислении}:
        \begin{itemize}
            \item Для операции $-$ норма $-$ отсутствие побочного эффекта. (Плохо, когда функция меняет состояние)
            \item Для операторов $-$ побочный эффект $-$ смысл их существования.
        \end{itemize}
        {\bf Тут язык Си: Hold my beer}.
        В языке Си нет оператора присваивания, так как существует оператор-выражение expresion;
        Это принципиально меняет подход к языку. Си унаследовал от Алгола-68 такую особенность.\\
        \underline{\bf Опр. 10} Ортогональность $-$ взаимозаменяемость.\\
        \underline{\bf Опр. 11} Независимость языковых конструкций $-$ допустимые конструкции имеют смысл в любом осмосмысленном контексте и могут быть взаимозаменямыми.\\
        Оператор не ортоганален выражению.
        Чтобы сделать оператор ортогональным, ему нужно дать значение. Выражденое значение $-$ тоже значение.
        Операторы имеют вычисляемое значение, а выражения - побочный эффект, поэтому они взаимозаменяемы.
        В Алголе-68 был описан не только синтаксис, но и семантику (С помощью двух уровневых грамматик какого-то мужика).

        \section{Задача о реверсе входной последовательности}
            Классическая задача обработки данных $-$ последовательность шагов.

            \begin{enumerate}
                \item Получить последовательность со входа.
                \item Сохранить в какой-нибудь контейнер.
                \item Перевернуть исходную последовательность.
                \item Вывести перевёрнутую последовательность.
            \end{enumerate}

        Рассмотрим простейшие примеры программ на различных языках.
        \subsection{Реверс последовательности на Си}
            Первый вариант программы надёжен, но присутствуют ограничения, которые не обговаривались в первоночальном условии.
            \lstinputlisting[language=C]{./examples/lection_1/reverse1.c}
            Более правильный вариант программы с использованием динамической памяти представлен во втором примере.
            \lstinputlisting[language=C]{./examples/lection_1/reverse2.c}
            Из особенностей можно выделить статическую явную типизацию, а также прямую работу с динамической памятью.
            Опять же второй код написан безопасно, и отслеживает переполнение динамической памяти.
        \subsection{Реверс последовательности на Go}
            В первом примере программа написана не корректно, предлагается посмотреть внимательно, и понять в чём ошибка.
            \lstinputlisting[language=Go]{./examples/lection_1/bad_go.go}
            
            На самом деле всё просто. В Go отсутствует тип данных char, из-за чего такой вывод последовательности не верен, и вместо
            побуквенного вывода строки мы получаем побайтовый вывод, что в корне не соответствует нашей задаче.
            Рассмотрим второй пример на котором данная ошибка исправлена.
            \lstinputlisting[language=Go]{./examples/lection_1/good_go.go}
            
            Вместо типа char, в Go используется тип динамической строки. Которая разбивается на маленькие подстроки, а потом соединяется в целую строку в обратной последовательности.
            И только потом печатается на экран.
            Первый язык Си появился в 1969 году был образован от цепочки языков. CPL=>BCPL=>B=>C. От B язык Си унаследовал
            скобки, синтаксис управляющих конструкций, устаревший синтаксис функций и auto.
            Существующие стандарты C89, C99, C11, C18, C2x
        \section{Язык Go}
            Язык Go (Google $-$ К. Томпсон, Р. Пайк, Р. Гризмер)
            Из особенностей можно выделить отказ от некоторых концепций ООЯП 
            (отсутствие понятия класса с наследованием, перегрузка функций, обобщённое программирование).
            Отказ от большинства оопераций с побочным эффектом и адресной арифметики.
            Автоматическая сборка мусора, очень развитая многопточность, есть элементы ФП (замыкания, анонимные функции).
            Его ниша $-$ разработка прикладных сервисов и утилит, но не системное программирование.
            В OS Fuchsia пытались использовать Go, но в итоге не вышло.
        \section{Императивная парадигма язык Python}
            Ведущий в нише научного программирования, где нет огромного количества вычислений с плав. точкой.
            Python $-$ интерпритируемый язык с динамической типизацией и автоматической сборкой мусора, наследник языка ABC.
            Первая версия появилась в 1991 (Гвидо Ван Россум BDFL (Благожилательный диктатор пожизенно) 2018).
            Python 2 $-$ появился в 2000 и закончил свою поддержку на версии 2.7.18 в 2020.
            Python 3 $-$ (Не полностью совместим с 2) $-$ 2008 год, текущая версия 3.9.1.
            Разработкой языка занимается сообщество питонистом $-$ роль стандартов играют PEP (Python Enchancement Proposals)
            При развитии языка появились элементы ФП и ООП, очень огромная стандартная библиотека и пользовательская дбиблиотека.
            Его ниша плавно перетекает с научного в индустриальное программирование. и веб программирование.
            Он уступает по производительности многим языкам.\\
            \textbf{Есть два стула c++ и Python, а Go посередине}\\
            В Python нет реверса строк \textbf{И это правильно}, зато есть мощное понятие вырезки.
    \chapter{Объектно-императивная пардигма}
        Объект <=> состояние + поведение (класс)
        Главный механизм данной парадигмы $-$ передача сообщений.
        Состояние => структура данных. Поведение => процедуры и функции, аргументом которых является объект.
        Объекты посылают друг другу сообщения $-$ посылка сообщения это вызов соответствующего метода класса. 
        В с++ это виртуальные методы, Smalltalk $-$ динамический поиск метода-обработчика сообщения.
        Классом назвается набор параметров и методов $-$ функций для доступа к параметрам. При этом метод это именно функция доступа.
        Объекты с идентичной структурой состояния и идентичным поведением объединяются в понятие типа данных.
        Важным моментом является понятие отношений между классами.
        Также Объекто-импертаивная парадигма отличается богатой стандартной библиотекой.

        \section{Язык C\#}
\begin{lstlisting}
using System;
public class Program {
    static void Main(string[] args) {
        string s = Console.In.ReadToEnd();
        char[] seq = s.ToCharArray();
        Array.Reverse(seq);
        Console.Write(seq);
    }
}
\end{lstlisting}
            Одна из причин почему нет ревеса $-$ необходимо переставить элементы.
            Внутри строки нельзя переставить элементы, так как в большинстве своём строки неизменяемы.
            А вот массивы $-$ изменяемый тип данных и поэтому там есть разворот \textbf{Array.Reverse}.
        \section{Обобщённое программирование язык С++}
            Обобщённое программирование $-$ программирование где все типы статические.
            Применяется механизм шиблонов. В С++ стандартная библиотека состоит из CRTL и STL.
            CRTL $-$ C Runtime Library, стандартная библиотека C.
            STL $-$ Библиотека в которой находятся контеёнеры и алгоритмы, причм контейнеры ничего не знают о алгоритмах,
            а алгоритмы ничего не знают о контейнерах. А как же совместить? Используются итераторы, некоторое подобие указателей.
            Для реализации задачи сначала выберается алгоритм, а затем контейнер, с которым выбранный алгоритм будет эффективно работать.
            При этом \textbf{cin} $-$ так же контейнер. Как пример для реверса последовательности нам нужен контейнер с двуноправленным 
            итератором. Алгоритм $-$ копирование \textbf{copy(beginIt, endIt, whereIt)}.
            Немного пвсевдокода, как вставлять в массив с помощью итератора?
\begin{lstlisting}
std::vector v;
copy_from_cin_to_v: copy(begin_it_cin, end_it_cin, iterToV)
\end{lstlisting}
            Для получения итераторов cin используется \textbf{istream\_iterator}.
            При этом:
            \begin{itemize}
                \item istream\_iterator(cin) $-$ аналог begin()
                \item istream\_iterator() $-$ аналог end()
            \end{itemize}
            Также есть \textbf{back\_inserter} $-$ аналог \textbf{push\_back()}.

\begin{lstlisting}
#include<iostream>
#include<vector>
#include<algorithm>
#include<iterator>

using namespace std;

int main() {
    std::vector<char> v;
    std::copy(istream_iterator<char>(cin), istream_iterator<char>(), back_inserter(v));
    std::copy(v.rbegin(), v.rend(), ostream_iterator<char>(cout));
}
\end{lstlisting}
            Таким образом, в С++ можно достичь огромный уровень абстрации.
    \chapter{Функциональная парадигма}
        Основная концепция:
        \begin{itemize}
            \item основные операции $-$ вызов (вычисление) функции и композиция функций.
            \item функции $-$ базисные + определяемые программистом
            \item функции $-$ объекты первого порядка, то есть могут быть значениями переменных, воззвращаемыми
                и передаваемыми значениями, могут быть созданы динамически (не путать с вызовом функции)
            \item переменные не меняют значения, а отождествляются со своими значениями на всё время существования переменной.
        \end{itemize}
        Таким образом, понятие явного хранимомго состояния отсутствует. 
        При чём программы на функциональных языках значительно проще распараллеливать чем на императивных.
        Функциональные языки: FP, Haskell, Lisp, ML, Hope, Miranda.
        \section{Язык COMON Lisp}
            Почему Lisp?
            \begin{itemize}
                \item Первый ЯП с элементами функциональными конструкциями
                \item ...
                \item ...
            \end{itemize}

            \textbf{Lis}t \textbf{P}rocessing $-$ 1958 Джон Маккарти (MIT) $-$ вначале чисто теоритический инструмент.
            Далее (1959-62) превратился в ЯП для обработки символьной информации. Стал de-facto стандартом в нише исследований по ИИ.
            
            Примитивными данными в Lisp являются атомы.
            Атом $-$ символ или целая константа (произвольного размера)
            Особым атомом является \textbf{()}, другое обозначение \textbf{NIL}, является обозначением пустого списка.
            Пример:
\begin{lstlisting}
ident 42 + NIL T
\end{lstlisting}
            Главная и единственная структура данных $-$ S-выражение, которая является атомом с точечной парой.
            Точечной парой является пара S-выражений причём голова является либо атомом либо списком, а хвост может быть только списком.
            Пример: 
\begin{lstlisting}            
(a . b) - неверно
(nil . abc) - неверно
(nil . nil) - верно
(a . (b . c)) - неврно
(a . (b . (c . nil))) - верно
\end{lstlisting}
            Парадигма работы интерпритатора Lisp $-$ REPL (Read Evaluate Print Loop).
            Атом вычисляет сам себя, пустой список тоже сам себя вычисляет. А атом символ вычисляет себя в значение.
            Символ инициализируется двумя способами: символ базисный, либо мы его задали какой-либо функцией.
            Как вычисляется список? Берётся первый элемент, который обязан быть определённым символом, он не вычисляется.
            Затем вычисляются все остальные символы, отождествляются с порядком аргументов функции и вычисляется тело функции.
\begin{lstlisting}
>>> 5
5
>>> nil
NIL
>>> A
ERROR
>>> (+ 1 2 3)
6
\end{lstlisting}
            Ещё стандартные функции:
            \begin{itemize}
                \item (CAR S) $-$ возвращает голову точечно пары списка S.
                \item (CDR S) $-$ возвращает хвост точечной пары списка S, при этом если S $-$ атом, то будет ошибка.
                \item (CONS A B) $-$ возвращает правильную точечную пару А В
            \end{itemize}
            Так же есть специальные функции, например \textbf{QUOTE}, которая просто отменяет вычисления списка.
            \textbf{CDDR} $-$ CDR от CDR.
\begin{lstlisting}
>>> (CAR A)
ERROR
>>> (CAR (QOUTE (A B)))
A
>>> (CDR (QOUTE (A B)))
(B)
>>> (CDDR (QOUTE (A B)))
()
>>> (CONS (QUOTE A) ())
(A)
>>> (CONS (QUOTE A) (B C))
(A B C)
\end{lstlisting}
            \textbf{QUOTE} стали заменять символом \'.
            Другая специальная функция \textbf{(IF B S1 S2)}, вычисляет B, если B истино, то вычисляется S1, иначе S2.
            А что такое истина? Если 0 то ложно, иначе истино. Т.е. если B вычислится как пустой указатель $-$ nil, то ложь,
            иначе истина. \textbf{NULL A} $-$ если A - пустой список, то возвращает T, иначе NIL.
            Решим теперь задачу о реверсе входной последовательности
\begin{lstlisting}
>>> (print (reverse (quote (a b c))))
(c b a)
>>> (print (reverse (read)))
(a b c)
(c b a)
\end{lstlisting}
\end{document}
