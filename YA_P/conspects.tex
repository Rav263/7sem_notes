\documentclass[a4paper, 12pt, titlepage, finall]{extreport}

%различные пакеты

\usepackage[T1, T2A]{fontenc}
\usepackage[russian]{babel}
\usepackage{tikz}
\usepackage{geometry}
\usepackage{indentfirst}
\usepackage{fontspec}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{array}
\graphicspath{{./images/}}

\usetikzlibrary{positioning, arrows}

\geometry{a4paper, left = 15mm, top = 10mm, bottom = 20mm, right = 15mm}

\setmainfont{Spectral Light}%{Times New Roman}
\setmonofont{DejaVu Sans Mono}
%\setcounter{secnumdepth}{3}
%\setcounter{tocdepth}{3}

\lstdefinestyle{customc}{
  belowcaptionskip=1\baselineskip,
  breaklines=true,
  frame=L,
  xleftmargin=\parindent,
  language=C,
  showstringspaces=false,
  basicstyle=\footnotesize\ttfamily,
  keywordstyle=\bfseries\color{green!40!black},
  commentstyle=\itshape\color{purple!40!black},
  identifierstyle=\color{blue},
  stringstyle=\color{orange},
}

\lstdefinestyle{customasm}{
  belowcaptionskip=1\baselineskip,
  frame=L,
  xleftmargin=\parindent,
  language=[x86masm]Assembler,
  basicstyle=\footnotesize\ttfamily,
  commentstyle=\itshape\color{purple!40!black},
}

\lstset{escapechar=@,style=customc}

\begin{document}

    \begin{titlepage}
        \begin{center}
            {\small \sc Московский государственный университет имени М.~В.~Ломоносова\\
            Факультет вычислительной математики и кибернетики\\
            Кафедра автоматизации систем вычислительных комплексов\\}
            \vfill
            {\large \sc Конспекты лекций.}\\~\\

            {\large \bf Языки программирования.}\\~\\

        \end{center}
        
        \begin{flushright}
            \vfill
            \vfill
            {Никифоров Никита Игоревич, 421 группа}\\
            {Лектор:}\\
            {Головин Игорь Генадьевич}\\
        \end{flushright}

        \begin{center}
            \vfill
            {\small Москва\\2020}
        \end{center}
    \end{titlepage}

    \chapter*{Аннотация}
        В данном курсе. 
        Скорее всего отчётностью будет экзамен. Если заочно то устный (Это что-то пи*** какой-то). Если очный то письменный. Почта лектора igolovin@gmail.com.
    \newpage
    \tableofcontents
    \newpage
    \chapter*{Введение}
        \addcontentsline{toc}{chapter}{\protect\numberline{}Введение}%
        Давайте обсудим, что такое Языки программирования (ЯП). Попробуем ввести определение ЯП.
        \begin{enumerate}
            \item Экстенсиальное $-$ Попробуем перечислить все языки программирования. Java, C, C++, C\#.
            В настоящее время насчитывается тысячи языков программирования. Поэтому данное определение нам не подходит.
            \item От обратного $-$ Обозначим что не является языком программирования: Русский, Английский, Эсперанто $-$ определённо нет!
            Нужна ли я алгоритмическая полнота для языка? Не обязательно: SQL-92 не является алгоритмически полным.
            \item Интенсиональное (Через свойства) $-$ ЯП, это инструмент для планирования поведения исполнителя. (В. Ш. Кауфман)
            ЯП $-$ формальноя нотация для записи компьютерных программ (CSS $-$ ЯП, но пробелы лишние не ставь!) 
        \end{enumerate}

        \underline{\bf Опр. 1} Исполнителем назовём управляеиое автоматическое поведение.\\
        Ford $-$ не исполнитель, так как водителю нужно крутить баранку, а вот Yandex мобиль $-$ вполне.
        Первый исполнитель $-$ ткацкие станки Жаккарда (начало 19-ого века).
        В нашем случае исполнителем будет универсальная вычислительная система. Мы будем рассматривать ЯП, которые удовлетворяют двум свойствам:
        \begin{itemize}
            \item Универсальность
            \item Индустриальность
        \end{itemize}
    \chapter{Виды Программирования}
        Определим виды программирования:
        \section{Игровое программирование}
            \underline{\bf Опр. 2} Игровое программирование $-$ необходимо для развлечения и обучения.\\
            Как пример задачи на ejudge (для себя, а не для Чернова).
            Первый игровой язык $-$ BASIC. Beginners All-purpose Symbolic Instruction Code.
            Второй самый популярный игровой язык $-$ Паскаль (1970).
\begin{lstlisting}
LET H$ = 'Hello'
LET W$ = 'world!'
PRINT H
PRINT W

DIM A(10)
FOR I = 1,10
A(I) = I
NEXT I
\end{lstlisting}
            Программы написаные на таких языках нужны только человеку их написавшему. А повторное использование стремится к нулю.
        \section{Научное программирование}
            \underline{\bf Опр. 3} Научное программирование $-$ программы написанные для выполнения какой-либо цели (вычисления, экспериментальное исследование и т.д.).\\
            Основное отличие от игровых ЯП $-$ программа написана и нужна определённому кругу людей. Повторное использование $-$ почти минимальное.
            Программа нужна для получения какого-то результата. Некоторые программы перерастают во что-то большее, но при этом обычно переписываются с нуля.
            Самый популярный и известный ЯП для научного программирования: \textbf{FOR}mulae \textbf{TRAN}slator $-$ (Джон Бэкус)
            FORTRAN $-$ самый первый и самый удачный.
            \begin{itemize}
                \item Чётко поставленный и достигнутые главные цели $-$ заменить посредника между математиком и компьютером, обеспечить приемлемую эффективность вычислений.
                \item Дополнительные эффекты (Неожиданные) $-$ прежде всего, мобильность знаний, которая была дополнена мобильностью программ, 
                что привело к накоплению ОГРОМНОГО количества библиотек для научных вычислений.
                \item До сих пор самый эффективный язык для "number crunching"
            \end{itemize}
            Чем плох FORTRAN:
            \begin{itemize}
                \item Только статические данные. Соответсвенно отсутствие рекурсии и динамических структур данных.
                \item Очень слабые и ненадёжные межмодульные связи.
                \item Отсутствие структурных управляющих конструкций (4 вида операций переходв, один оператор цикла и т.д.
                \item Единственная структура данных - массив (Как вектор, тензор)
                \item Единственный вид модуля - подпрограмма (функции и процедуры)
            \end{itemize}

\begin{lstlisting}
if (E) 10, 20, 30
\end{lstlisting}
             Если E < 0 переход на метку 10\\
             Если E == 0 переход на метку 20\\
             Если E > 0 переход на метку 30\\
             Наследние IBM 7090.\\
             FORTRAN $-$ Одновременно и самый плохой и самый удачный ЯП. Почему оба утверждения верны и не противорячат друг другу?
             Тут работает принцип экологической ниши языка.\\
             \underline{\bf Опр. 4} Экологическая ниша языка $-$ это проблемная область (или набор проблемных областей), в которой применяется ЯП.\\
             В ней может быть только одна доминанта, и вид должен подходить для этой ниши: если ЯП подходит для этой ниши, и он первый, то его от туда никто не вытеснит.
             Примеры проблемных областей:
             \begin{itemize}
                \item Научные высокопроизводительные вычисления.
                \item Научные эксперементальные вычисления.
                \item Системное программирование. (Си)
                \item Бухгалтерия, финансы (На самом деле - множество ПО) (Первый COBOL).
            \end{itemize}

            \underline{\bf Опр. 5} Занятие ниши $-$ означает то, что язык подходит для этой ниши, то есть пользователи языка (программисты) активно используют ЯП.\\
            Вытеснение языка из ниши происходит при изменнение условий в нише, а вовсе не из-за появления нового {\bf Ну очень офигенного}. 
            Именно поэтому Фортран до сих пор чувствуеет себя прекрасно в своей нише высокопроизводительных вычислений.
            А в экспериментальных вычислений он потихоньку уступает конкурентам (Python, Ruby, МатЛаб).
            Проблеммы FORTRAN начались, когда его стали использовать где попало. Например: системное программирование, управление устройствами и т.п.
            По причине его не надёжности.
            Надёжность языка характиризуется тем, насколько язык провоцирует надёжность (уменьшает надёжность)
            Пример:
\begin{lstlisting}
DO 5 I=1,3
A(I)=A(I) + C
5 CONTINUE
\end{lstlisting}
            
            {\bf НЕ ПУТАЙ ТОЧКИ И ЗАПЯТЫЕ, РАКЕТЫ ПАДАЮТ!!!}
            
            Вторым удачным языком для научных вычислений был АЛГОЛ (ALGOrithmic Language) $-$ первая версия (1958) год.
            Окончательный вариант АЛГОЛ-60
            Журнал Communication of ACM с 1960 годов, публикует алгоритмы на алголе-60.
        \section{Индустриальное программирование}
            Главные критерии различия $-$ круг пользователей программы и степень отчуждаемости.\\
            \underline{\bf Опр. 6} Индустриальное программирование $-$ создание программных продуктов, то есть программ и систем, 
            которые обязательно отчуждаются, то есть используются независимо от автора.\\
            Огромное количество проблемных областей.
            Требованиями к индустриальному ЯП будем называть технологическими требованиеми.
            Одним из самых важных технологических требований является возможность разделение программы на части, и их раздельная разработка (модульность).
            Примеры ТП:
            \begin{itemize}
                \item ПО - встроенное программное обеспечение работающее в реальном времени для низкоресурсных устройств (С++, Ада).
                \item Сайт магазина или стартапа, веб программирование (PHP, JavaScript, Python).
            \end{itemize}
            В данном курсе мы будем рассматривать ТОЛЬКО ЯП для индустриального программирования.
            Что мы будем изучать?
            \begin{enumerate}
                \item Как ЯП отвечают наиболее общим ТП.
                \item Общие свойства ЯП, используемых в современной индустрии разработки ПО (Различные парадигмы программирования).
            \end{enumerate}
            
    \chapter{ЯП и парадигмы программирования}
        \underline{\bf Опр. 7} Парадигма программирования - совокупность идей, методов. понятий, определяющих стиль программирования и способ мышления при создании программ.\\
        Существую три базисные парадигмы:
        \begin{itemize}
            \item императивная
            \item Функциональная
            \item Логическая
        \end{itemize}
        Все остальные подпарадигмы основаны на трёх базисных парадигмах и вкладываются в них. Например объектно-ориентированная парадигма основана на императивной парадигме.\\
        \underline{\bf Опр. 8} Обобщённое программирование (generic programming) $-$ статическая типизация типов (Родовые сегменты в Аде, шаблоны в c++).\\
        Зачем нам парадигма программирования? ВАжно понимать концепции парадигм и то, как они отражаются в конкретных ЯП.
        Современные индустриальные ЯП $-$ либо чисто императивные, либо содержат элементы других парадигм, но с доминированием одной.\\
        {\bf И тут Бэкус достаёт из кармана функциональные языки}\\
        Бэкус: Может ли программирование быть освобождено от фоннеймовской парадигмы?
        Чистые функциональные языки сложно назвать индустриальными. {\bf С функциональными языками как: Ты в дверь, они в окно}.
        При чём, многие вещи из функциональных языков перетикают идеи функциональных языков.
        Будем рассматривать алгоритм разварота входной последовательности символов.
    \chapter{Императивная парадигма}
        Основана на т.н. фон-неймановской модели
        \begin{itemize}
            \item ОЗУ <=> ЦПУ <=> ВЗУ.
            \item ОЗУ <=> программа + данные.
            \item ЦПУ <=> УУ + АЛУ
        \end{itemize}
        \underline{\bf Опр. 9} Главное понятие ИмпПП $-$ {\bf состояние} (храниться в памяти и ЦП).\\
        Существует некоторая функция, отображающее текущее состояние в следующее, такая функция и задаёт семантику работы программы.
        Команды ЯА:
        \begin{itemize}
            \item пересылки между ОП и регистрами ЦПУ (MOV)
            \item арифметико-логические команды (ADD)
            \item Команды управления (JMP, HALT)
            \item Команды ввода\\вывода.
        \end{itemize}
        Все команды в ЯА изменяют состояние. Состояние $-$ основное понятие императивных ЯП.
        Параллельность противоречит императивной парадигме.

        Оператор $-$ statement (loop statement, assignment statement,...)\\
        Операция $-$ operator (C++)\\
        
        В чём отличие операторов и операций? {\bf В понятии побочного эффекта, то есть изменения состояния при вычислении}:
        \begin{itemize}
            \item Для операции $-$ норма $-$ отсутствие побочного эффекта. (Плохо, когда функция меняет состояние)
            \item Для операторов $-$ побочный эффект $-$ смысл их существования.
        \end{itemize}
        {\bf Тут язык Си: Hold my beer}.
        В языке Си нет оператора присваивания, так как существует оператор-выражение expresion;
        Это принципиально меняет подход к языку. Си унаследовал от Алгола-68 такую особенность.\\
        \underline{\bf Опр. 10} Ортогональность $-$ взаимозаменяемость.\\
        \underline{\bf Опр. 11} Независимость языковых конструкций $-$ допустимые конструкции имеют смысл в любом осмосмысленном контексте и могут быть взаимозаменямыми.\\
        Оператор не ортоганален выражению.
        Чтобы сделать оператор ортогональным, ему нужно дать значение. Выражденое значение $-$ тоже значение.
        Операторы имеют вычисляемое значение, а выражения - побочный эффект, поэтому они взаимозаменяемы.
        В Алголе-68 был описан не только синтаксис, но и семантику (С помощью двух уровневых грамматик какого-то мужика).

        \section{Задача о реверсе входной последовательности}
            Классическая задача обработки данных $-$ последовательность шагов.

            \begin{enumerate}
                \item Получить последовательность со входа.
                \item Сохранить в какой-нибудь контейнер.
                \item Перевернуть исходную последовательность.
                \item Вывести перевёрнутую последовательность.
            \end{enumerate}

        Рассмотрим простейшие примеры программ на различных языках.
        \subsection{Реверс последовательности на Си}
            Первый вариант программы надёжен, но присутствуют ограничения, которые не обговаривались в первоночальном условии.
            \lstinputlisting[language=C]{./examples/lection_1/reverse1.c}
            Более правильный вариант программы с использованием динамической памяти представлен во втором примере.
            \lstinputlisting[language=C]{./examples/lection_1/reverse2.c}
            Из особенностей можно выделить статическую явную типизацию, а также прямую работу с динамической памятью.
            Опять же второй код написан безопасно, и отслеживает переполнение динамической памяти.
        \subsection{Реверс последовательности на Go}
            В первом примере программа написана не корректно, предлагается посмотреть внимательно, и понять в чём ошибка.
            \lstinputlisting[language=Go]{./examples/lection_1/bad_go.go}
            
            На самом деле всё просто. В Go отсутствует тип данных char, из-за чего такой вывод последовательности не верен, и вместо
            побуквенного вывода строки мы получаем побайтовый вывод, что в корне не соответствует нашей задаче.
            Рассмотрим второй пример на котором данная ошибка исправлена.
            \lstinputlisting[language=Go]{./examples/lection_1/good_go.go}
            
            Вместо типа char, в Go используется тип динамической строки. Которая разбивается на маленькие подстроки, а потом соединяется в целую строку в обратной последовательности.
            И только потом печатается на экран.
\end{document}
